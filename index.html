<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures and Algorithms Reference</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #2c3e50;
            --success-color: #27ae60;
            --warning-color: #f39c12;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            line-height: 1.6;
            color: #333;
            background-color: #f9f9f9;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            border-radius: 10px;
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }
        
        .module-nav {
            background-color: var(--light-color);
            padding: 15px;
            border-bottom: 2px solid var(--secondary-color);
        }
        
        .module-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            list-style: none;
            gap: 10px;
        }
        
        .module-list li {
            background-color: white;
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid var(--secondary-color);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .module-list li:hover {
            background-color: var(--secondary-color);
            color: white;
            transform: translateY(-2px);
        }
        
        .module-list li.active {
            background-color: var(--secondary-color);
            color: white;
            font-weight: bold;
        }
        
        .content {
            display: flex;
            min-height: 800px;
        }
        
        .sidebar {
            width: 250px;
            background-color: var(--light-color);
            padding: 20px;
            border-right: 1px solid #ddd;
            overflow-y: auto;
        }
        
        .sidebar h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--secondary-color);
        }
        
        .module-menu {
            list-style: none;
        }
        
        .module-menu li {
            margin-bottom: 8px;
        }
        
        .module-menu a {
            display: block;
            padding: 10px 15px;
            color: var(--dark-color);
            text-decoration: none;
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        
        .module-menu a:hover {
            background-color: var(--secondary-color);
            color: white;
        }
        
        .module-menu a.active {
            background-color: var(--secondary-color);
            color: white;
            font-weight: bold;
        }
        
        .main-content {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }
        
        .module {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .module.active {
            display: block;
        }
        
        h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--secondary-color);
        }
        
        h3 {
            color: var(--primary-color);
            margin: 25px 0 15px 0;
        }
        
        .definition {
            background-color: #f8f9fa;
            padding: 15px;
            border-left: 4px solid var(--secondary-color);
            margin: 15px 0;
            border-radius: 0 5px 5px 0;
        }
        
        .code-container {
            background-color: #2d3a4b;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: #ccc;
            font-size: 0.9rem;
        }
        
        .code-copy {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .code-copy:hover {
            background-color: #2980b9;
        }
        
        .complexity {
            background-color: #e8f4fc;
            border: 1px solid var(--secondary-color);
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        .complexity h4 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        .comparison-table th {
            background-color: var(--primary-color);
            color: white;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .visualization {
            background-color: #f0f7ff;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            text-align: center;
        }
        
        .visual-box {
            display: inline-block;
            width: 50px;
            height: 50px;
            line-height: 50px;
            text-align: center;
            background-color: var(--secondary-color);
            color: white;
            margin: 5px;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .visual-pointer {
            font-size: 1.5rem;
            margin: 0 10px;
            color: var(--accent-color);
        }
        
        footer {
            text-align: center;
            padding: 20px;
            background-color: var(--primary-color);
            color: white;
            margin-top: 30px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @media (max-width: 768px) {
            .content {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #ddd;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Data Structures and Algorithms</h1>
            <div class="subtitle">A Comprehensive Reference Guide with C++ Implementation</div>
            <p>Complete coverage of 12 modules covering fundamental to advanced concepts</p>
        </header>
        
        <div class="module-nav">
            <ul class="module-list" id="moduleNav">
                <!-- Module navigation will be populated by JavaScript -->
            </ul>
        </div>
        
        <div class="content">
            <div class="sidebar">
                <h3>Module Contents</h3>
                <ul class="module-menu" id="moduleMenu">
                    <!-- Module menu will be populated by JavaScript -->
                </ul>
            </div>
            
            <div class="main-content" id="mainContent">
                <!-- Module content will be populated by JavaScript -->
            </div>
        </div>
        
        <footer>
            <p>Data Structures & Algorithms Reference | Created for educational purposes</p>
        </footer>
    </div>
    
    <script>
        // Data structure for all modules
        const modules = [
            {
                id: 1,
                title: "Module 1: Fundamental Concepts",
                topics: [
                    {
                        id: "1.1",
                        title: "The Concept of Data Type",
                        content: `
                            <p>A data type defines a set of values and the operations that can be performed on those values. It's a classification that specifies:</p>
                            <ul>
                                <li>Possible values for that type</li>
                                <li>Operations that can be performed on values of that type</li>
                                <li>The way values of that type are stored in memory</li>
                            </ul>
                            
                            <div class="definition">
                                <strong>Definition:</strong> A data type is a classification of data which tells the compiler or interpreter how the programmer intends to use the data.
                            </div>
                            
                            <h4>C++ Example:</h4>
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Data Type Declaration in C++</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
// Different data types in C++
int age = 25;               // Integer type
float salary = 2500.50;     // Floating-point type
char grade = 'A';          // Character type
bool isEmployed = true;    // Boolean type
double pi = 3.14159265359; // Double precision floating-point

// User-defined data type
struct Person {
    string name;
    int age;
    float height;
};

Person person1; // Creating a variable of user-defined type
</pre>
                            </div>
                        `
                    },
                    {
                        id: "1.2",
                        title: "Primitive Data Types",
                        content: `
                            <p>Primitive data types are the most basic data types available in a programming language. They are built-in and directly supported by the compiler.</p>
                            
                            <h4>Characteristics of Primitive Data Types:</h4>
                            <ul>
                                <li>They are predefined by the language</li>
                                <li>They are named by a reserved keyword</li>
                                <li>They are not composed of other data types</li>
                                <li>They have fixed memory size (usually)</li>
                            </ul>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>C++ Primitive Data Types</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    // Integer types
    int integerNum = 42;           // Typically 4 bytes
    short shortNum = 100;          // Typically 2 bytes
    long longNum = 100000L;        // Typically 4 or 8 bytes
    long long veryLongNum = 10000000000LL; // Typically 8 bytes
    
    // Floating-point types
    float floatNum = 3.14f;        // Single precision, 4 bytes
    double doubleNum = 3.141592;   // Double precision, 8 bytes
    long double longDouble = 3.14159265358979L; // Extended precision
    
    // Character types
    char character = 'A';          // 1 byte
    wchar_t wideChar = L'Ω';       // Wide character (2 or 4 bytes)
    
    // Boolean type
    bool boolean = true;           // 1 byte
    
    cout << "Size of int: " << sizeof(int) << " bytes" << endl;
    cout << "Size of double: " << sizeof(double) << " bytes" << endl;
    
    return 0;
}
</pre>
                            </div>
                        `
                    },
                    {
                        id: "1.3",
                        title: "Standard Primitive Types",
                        content: `
                            <p>Standard primitive types are the basic data types that are directly supported by most programming languages.</p>
                            
                            <h4>Common Standard Primitive Types:</h4>
                            <table class="comparison-table">
                                <thead>
                                    <tr>
                                        <th>Data Type</th>
                                        <th>Size (bytes)</th>
                                        <th>Range</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>int</td>
                                        <td>4</td>
                                        <td>-2,147,483,648 to 2,147,483,647</td>
                                        <td>Integer values</td>
                                    </tr>
                                    <tr>
                                        <td>float</td>
                                        <td>4</td>
                                        <td>±3.4e-38 to ±3.4e38</td>
                                        <td>Single-precision floating point</td>
                                    </tr>
                                    <tr>
                                        <td>double</td>
                                        <td>8</td>
                                        <td>±1.7e-308 to ±1.7e308</td>
                                        <td>Double-precision floating point</td>
                                    </tr>
                                    <tr>
                                        <td>char</td>
                                        <td>1</td>
                                        <td>-128 to 127 or 0 to 255</td>
                                        <td>Single character/byte</td>
                                    </tr>
                                    <tr>
                                        <td>bool</td>
                                        <td>1</td>
                                        <td>true or false</td>
                                        <td>Boolean values</td>
                                    </tr>
                                </tbody>
                            </table>
                        `
                    },
                    {
                        id: "1.4",
                        title: "The Type BOOLEAN",
                        content: `
                            <p>The Boolean data type is named after George Boole, who first defined an algebraic system of logic. It represents truth values: true and false.</p>
                            
                            <h4>Boolean Characteristics:</h4>
                            <ul>
                                <li>Only two possible values: true or false</li>
                                <li>Often implemented as 1 byte in memory (though only 1 bit is theoretically needed)</li>
                                <li>Used in conditional statements and logical operations</li>
                            </ul>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Boolean Operations in C++</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    bool a = true;
    bool b = false;
    
    // Logical operations
    bool andResult = a && b;    // Logical AND: false
    bool orResult = a || b;     // Logical OR: true
    bool notResult = !a;        // Logical NOT: false
    
    // Boolean in conditions
    if (a) {
        cout << "a is true" << endl;
    }
    
    // Boolean as result of comparison
    int x = 10, y = 20;
    bool isEqual = (x == y);    // false
    bool isGreater = (x > y);   // false
    bool isLess = (x < y);      // true
    
    // Boolean output
    cout << boolalpha;  // Display true/false instead of 1/0
    cout << "a && b: " << andResult << endl;
    cout << "a || b: " << orResult << endl;
    cout << "!a: " << notResult << endl;
    
    return 0;
}
</pre>
                            </div>
                        `
                    },
                    {
                        id: "1.5",
                        title: "Linear Data Structures",
                        content: `
                            <p>Linear data structures are those where data elements are arranged sequentially or linearly, with each element connected to its previous and next element.</p>
                            
                            <h4>Characteristics of Linear Data Structures:</h4>
                            <ul>
                                <li>Elements are arranged in a sequence</li>
                                <li>Each element has a unique predecessor and successor (except first and last)</li>
                                <li>Easy to implement and traverse</li>
                                <li>Memory allocation can be static or dynamic</li>
                            </ul>
                            
                            <h4>Examples of Linear Data Structures:</h4>
                            <ul>
                                <li><strong>Arrays:</strong> Contiguous memory locations</li>
                                <li><strong>Linked Lists:</strong> Nodes connected via pointers</li>
                                <li><strong>Stacks:</strong> LIFO (Last In, First Out) structure</li>
                                <li><strong>Queues:</strong> FIFO (First In, First Out) structure</li>
                            </ul>
                            
                            <div class="visualization">
                                <h4>Visualization of Linear Data Structure (Array)</h4>
                                <div>
                                    <span class="visual-box">10</span>
                                    <span class="visual-box">20</span>
                                    <span class="visual-box">30</span>
                                    <span class="visual-box">40</span>
                                    <span class="visual-box">50</span>
                                </div>
                                <p>Each element has a specific position (index)</p>
                            </div>
                        `
                    },
                    {
                        id: "1.6",
                        title: "Non-Linear Data Structures",
                        content: `
                            <p>Non-linear data structures are those where data elements are not arranged sequentially. Each element can have multiple predecessors and successors.</p>
                            
                            <h4>Characteristics of Non-Linear Data Structures:</h4>
                            <ul>
                                <li>Elements are connected in a hierarchical or graph-like manner</li>
                                <li>Elements can have multiple relationships</li>
                                <li>More complex to implement and traverse</li>
                                <li>Efficient for representing complex relationships</li>
                            </ul>
                            
                            <h4>Examples of Non-Linear Data Structures:</h4>
                            <ul>
                                <li><strong>Trees:</strong> Hierarchical structure with root and children</li>
                                <li><strong>Graphs:</strong> Collection of nodes and edges</li>
                                <li><strong>Hash Tables:</strong> Key-value pairs using hash functions</li>
                                <li><strong>Heaps:</strong> Complete binary tree with heap property</li>
                            </ul>
                            
                            <div class="visualization">
                                <h4>Visualization of Non-Linear Data Structure (Tree)</h4>
                                <pre style="text-align: left; background-color: white; padding: 15px; border-radius: 5px; display: inline-block;">
        A
       / \\
      B   C
     / \\   \\
    D   E   F
                                </pre>
                                <p>Elements are arranged hierarchically</p>
                            </div>
                        `
                    }
                ]
            },
            {
                id: 2,
                title: "Module 2: Arrays",
                topics: [
                    {
                        id: "2.1",
                        title: "Array Overview",
                        content: `
                            <p>An array is a collection of items stored at contiguous memory locations. All items are of the same type.</p>
                            
                            <h4>Key Characteristics:</h4>
                            <ul>
                                <li><strong>Fixed Size:</strong> Size is defined at declaration and cannot change</li>
                                <li><strong>Contiguous Memory:</strong> Elements are stored in adjacent memory locations</li>
                                <li><strong>Random Access:</strong> Any element can be accessed directly using index</li>
                                <li><strong>Homogeneous:</strong> All elements must be of the same data type</li>
                            </ul>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Array Declaration and Initialization in C++</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    // Array declaration
    int arr1[5];  // Declares an array of 5 integers
    
    // Array initialization
    int arr2[5] = {10, 20, 30, 40, 50};
    
    // Partial initialization (remaining elements are 0)
    int arr3[5] = {10, 20};  // arr3 = {10, 20, 0, 0, 0}
    
    // Size determined by initializer
    int arr4[] = {1, 2, 3, 4, 5};  // Size is 5
    
    // Accessing array elements
    cout << "First element: " << arr2[0] << endl;  // 10
    cout << "Third element: " << arr2[2] << endl;  // 30
    
    // Modifying array elements
    arr2[1] = 25;  // Changes second element to 25
    
    // Array traversal
    cout << "Array elements: ";
    for (int i = 0; i < 5; i++) {
        cout << arr2[i] << " ";
    }
    cout << endl;
    
    // Size of array
    cout << "Size of array in bytes: " << sizeof(arr2) << endl;
    cout << "Number of elements: " << sizeof(arr2) / sizeof(arr2[0]) << endl;
    
    return 0;
}
</pre>
                            </div>
                        `
                    },
                    {
                        id: "2.2",
                        title: "Linear Arrays",
                        content: `
                            <p>A linear array (or one-dimensional array) is the simplest form of array where elements are arranged in a single row.</p>
                            
                            <h4>Memory Representation:</h4>
                            <p>Elements are stored in contiguous memory locations. If the array starts at memory address <code>base</code> and each element occupies <code>size</code> bytes, then element at index <code>i</code> is located at:</p>
                            <p><code>Address = base + (i × size)</code></p>
                            
                            <div class="visualization">
                                <h4>Memory Representation of Linear Array</h4>
                                <table style="margin: 0 auto; border-collapse: collapse;">
                                    <tr>
                                        <td style="border: 1px solid #333; padding: 10px;">arr[0]</td>
                                        <td style="border: 1px solid #333; padding: 10px;">arr[1]</td>
                                        <td style="border: 1px solid #333; padding: 10px;">arr[2]</td>
                                        <td style="border: 1px solid #333; padding: 10px;">arr[3]</td>
                                        <td style="border: 1px solid #333; padding: 10px;">arr[4]</td>
                                    </tr>
                                    <tr>
                                        <td>1000</td>
                                        <td>1004</td>
                                        <td>1008</td>
                                        <td>1012</td>
                                        <td>1016</td>
                                    </tr>
                                </table>
                                <p>Assuming <code>int</code> takes 4 bytes, base address = 1000</p>
                            </div>
                        `
                    },
                    {
                        id: "2.3",
                        title: "Non-Linear Arrays (Multi-dimensional)",
                        content: `
                            <p>Multi-dimensional arrays are arrays of arrays. The most common is the two-dimensional array, which can be thought of as a table with rows and columns.</p>
                            
                            <h4>Two-Dimensional Array:</h4>
                            <p>A 2D array is essentially an array of 1D arrays. It's declared as <code>type arrayName[rows][columns]</code>.</p>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>2D Arrays in C++</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    // Declaration and initialization of 2D array
    int matrix[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    
    // Accessing elements
    cout << "Element at [1][2]: " << matrix[1][2] << endl;  // 6
    
    // Traversing 2D array
    cout << "Matrix elements:" << endl;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
    
    // Memory calculation for element at position [i][j]
    // For row-major order (used by C++):
    // Address = base + (i * columns + j) * size
    
    return 0;
}
</pre>
                            </div>
                            
                            <h4>Three-Dimensional Array:</h4>
                            <div class="code-container">
                                <div class="code-header">
                                    <span>3D Array Example</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    // 3D array: 2 layers, each 3x3 matrix
    int threeD[2][3][3] = {
        {   // First layer
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        },
        {   // Second layer
            {10, 11, 12},
            {13, 14, 15},
            {16, 17, 18}
        }
    };
    
    // Accessing element at [layer][row][column]
    cout << "Element at [1][2][1]: " << threeD[1][2][1] << endl;  // 17
    
    return 0;
}
</pre>
                            </div>
                        `
                    },
                    {
                        id: "2.4",
                        title: "Representation of Linear Array in Memory",
                        content: `
                            <p>Arrays are stored in contiguous memory locations. The way elements are mapped to memory addresses depends on the programming language and the type of array.</p>
                            
                            <h4>Memory Allocation for Arrays:</h4>
                            <p>When an array is declared, the compiler:</p>
                            <ol>
                                <li>Allocates a contiguous block of memory</li>
                                <li>Calculates the total memory needed: <code>size = number_of_elements × size_of_each_element</code></li>
                                <li>Assigns a base address (address of first element)</li>
                            </ol>
                            
                            <div class="visualization">
                                <h4>Array Memory Layout</h4>
                                <div style="display: flex; flex-direction: column; align-items: center;">
                                    <div style="display: flex; margin-bottom: 10px;">
                                        <div style="border: 1px solid #333; padding: 15px; background-color: #3498db; color: white;">arr[0]</div>
                                        <div style="border: 1px solid #333; padding: 15px;">arr[1]</div>
                                        <div style="border: 1px solid #333; padding: 15px;">arr[2]</div>
                                        <div style="border: 1px solid #333; padding: 15px;">arr[3]</div>
                                        <div style="border: 1px solid #333; padding: 15px;">arr[4]</div>
                                    </div>
                                    <div style="display: flex;">
                                        <div style="padding: 15px;">Address: 1000</div>
                                        <div style="padding: 15px;">1004</div>
                                        <div style="padding: 15px;">1008</div>
                                        <div style="padding: 15px;">1012</div>
                                        <div style="padding: 15px;">1016</div>
                                    </div>
                                </div>
                                <p>For an integer array (4 bytes per element)</p>
                            </div>
                            
                            <h4>Address Calculation Formulas:</h4>
                            <ul>
                                <li><strong>1D Array:</strong> <code>Address(A[i]) = Base_Address + i × size_of_element</code></li>
                                <li><strong>2D Array (Row-major):</strong> <code>Address(A[i][j]) = Base_Address + (i × columns + j) × size_of_element</code></li>
                                <li><strong>2D Array (Column-major):</strong> <code>Address(A[i][j]) = Base_Address + (j × rows + i) × size_of_element</code></li>
                            </ul>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Calculating Array Element Addresses</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    
    // Display addresses
    cout << "Memory addresses of array elements:" << endl;
    for (int i = 0; i < 5; i++) {
        cout << "Address of arr[" << i << "] = " << &arr[i] << endl;
    }
    
    // Calculate expected addresses
    cout << "\nCalculating addresses:" << endl;
    int base_address = (int)&arr[0];
    int element_size = sizeof(arr[0]);
    
    for (int i = 0; i < 5; i++) {
        int calculated_address = base_address + i * element_size;
        cout << "Calculated address of arr[" << i << "] = " 
             << calculated_address << endl;
    }
    
    return 0;
}
</pre>
                            </div>
                        `
                    }
                ]
            },
            {
                id: 3,
                title: "Module 3: Array Operations",
                topics: [
                    {
                        id: "3.1",
                        title: "Traversing Linear Arrays",
                        content: `
                            <p>Array traversal means accessing each element of the array exactly once to perform some operation.</p>
                            
                            <h4>Basic Traversal Techniques:</h4>
                            <ul>
                                <li><strong>Forward Traversal:</strong> Process elements from first to last</li>
                                <li><strong>Backward Traversal:</strong> Process elements from last to first</li>
                                <li><strong>Random Access:</strong> Access elements in any order using indices</li>
                            </ul>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Array Traversal Examples</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    // 1. Forward traversal
    cout << "Forward traversal: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    // 2. Backward traversal
    cout << "Backward traversal: ";
    for (int i = n - 1; i >= 0; i--) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    // 3. Using while loop
    cout << "Using while loop: ";
    int i = 0;
    while (i < n) {
        cout << arr[i] << " ";
        i++;
    }
    cout << endl;
    
    // 4. Using range-based for loop (C++11)
    cout << "Range-based for loop: ";
    for (int element : arr) {
        cout << element << " ";
    }
    cout << endl;
    
    // 5. Traversal with operations
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }
    cout << "Sum of elements: " << sum << endl;
    
    // 6. Finding maximum element
    int max = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    cout << "Maximum element: " << max << endl;
    
    return 0;
}
</pre>
                            </div>
                        `
                    },
                    {
                        id: "3.2",
                        title: "Searching in Arrays",
                        content: `
                            <p>Searching is the process of finding the location of a given element in an array.</p>
                            
                            <h4>Linear Search:</h4>
                            <p>Check each element one by one until the desired element is found.</p>
                            
                            <div class="complexity">
                                <h4>Time Complexity:</h4>
                                <ul>
                                    <li><strong>Best Case:</strong> O(1) - Element found at first position</li>
                                    <li><strong>Average Case:</strong> O(n) - Element found in the middle</li>
                                    <li><strong>Worst Case:</strong> O(n) - Element not found or at last position</li>
                                </ul>
                            </div>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Linear Search Implementation</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

// Linear search function
int linearSearch(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) {
            return i;  // Return index if found
        }
    }
    return -1;  // Return -1 if not found
}

int main() {
    int arr[] = {10, 23, 45, 70, 11, 15};
    int n = sizeof(arr) / sizeof(arr[0]);
    int key = 70;
    
    int result = linearSearch(arr, n, key);
    
    if (result != -1) {
        cout << "Element " << key << " found at index " << result << endl;
    } else {
        cout << "Element " << key << " not found in the array" << endl;
    }
    
    // Test with element not in array
    key = 100;
    result = linearSearch(arr, n, key);
    if (result == -1) {
        cout << "Element " << key << " not found in the array" << endl;
    }
    
    return 0;
}
</pre>
                            </div>
                            
                            <h4>Binary Search:</h4>
                            <p>Efficient searching algorithm for sorted arrays that repeatedly divides the search interval in half.</p>
                            
                            <div class="complexity">
                                <h4>Time Complexity:</h4>
                                <ul>
                                    <li><strong>Best Case:</strong> O(1) - Element found at middle</li>
                                    <li><strong>Average Case:</strong> O(log n)</li>
                                    <li><strong>Worst Case:</strong> O(log n)</li>
                                </ul>
                            </div>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Binary Search Implementation</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

// Iterative binary search
int binarySearch(int arr[], int n, int key) {
    int left = 0;
    int right = n - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // Avoid overflow
        
        if (arr[mid] == key) {
            return mid;  // Element found
        }
        
        if (arr[mid] < key) {
            left = mid + 1;  // Search in right half
        } else {
            right = mid - 1;  // Search in left half
        }
    }
    
    return -1;  // Element not found
}

// Recursive binary search
int binarySearchRecursive(int arr[], int left, int right, int key) {
    if (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == key) {
            return mid;
        }
        
        if (arr[mid] < key) {
            return binarySearchRecursive(arr, mid + 1, right, key);
        } else {
            return binarySearchRecursive(arr, left, mid - 1, key);
        }
    }
    
    return -1;
}

int main() {
    int arr[] = {2, 5, 8, 12, 16, 23, 38, 45, 56, 72};
    int n = sizeof(arr) / sizeof(arr[0]);
    int key = 23;
    
    int result = binarySearch(arr, n, key);
    
    if (result != -1) {
        cout << "Element " << key << " found at index " << result << endl;
    } else {
        cout << "Element " << key << " not found in the array" << endl;
    }
    
    // Using recursive approach
    key = 45;
    result = binarySearchRecursive(arr, 0, n - 1, key);
    if (result != -1) {
        cout << "Element " << key << " found at index " << result << " (recursive)" << endl;
    }
    
    return 0;
}
</pre>
                            </div>
                        `
                    },
                    {
                        id: "3.3",
                        title: "Insertion in Arrays",
                        content: `
                            <p>Insertion involves adding a new element to an array. Arrays have fixed size, so we need to be careful about capacity.</p>
                            
                            <h4>Insertion Scenarios:</h4>
                            <ul>
                                <li><strong>At the end:</strong> If array has space, simply add at the end</li>
                                <li><strong>At the beginning:</strong> Shift all elements right, then insert</li>
                                <li><strong>At specific position:</strong> Shift elements from that position onward</li>
                            </ul>
                            
                            <div class="complexity">
                                <h4>Time Complexity:</h4>
                                <ul>
                                    <li><strong>At the end:</strong> O(1)</li>
                                    <li><strong>At beginning/middle:</strong> O(n) - due to shifting</li>
                                </ul>
                            </div>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Array Insertion Operations</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

// Function to insert at the end
void insertAtEnd(int arr[], int &n, int capacity, int element) {
    if (n < capacity) {
        arr[n] = element;
        n++;
        cout << "Element " << element << " inserted at the end." << endl;
    } else {
        cout << "Array is full! Cannot insert." << endl;
    }
}

// Function to insert at beginning
void insertAtBeginning(int arr[], int &n, int capacity, int element) {
    if (n < capacity) {
        // Shift all elements to the right
        for (int i = n; i > 0; i--) {
            arr[i] = arr[i - 1];
        }
        arr[0] = element;
        n++;
        cout << "Element " << element << " inserted at the beginning." << endl;
    } else {
        cout << "Array is full! Cannot insert." << endl;
    }
}

// Function to insert at specific position
void insertAtPosition(int arr[], int &n, int capacity, int element, int position) {
    if (n >= capacity) {
        cout << "Array is full! Cannot insert." << endl;
        return;
    }
    
    if (position < 0 || position > n) {
        cout << "Invalid position!" << endl;
        return;
    }
    
    // Shift elements from position to end
    for (int i = n; i > position; i--) {
        arr[i] = arr[i - 1];
    }
    
    arr[position] = element;
    n++;
    cout << "Element " << element << " inserted at position " << position << "." << endl;
}

void displayArray(int arr[], int n) {
    cout << "Array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    const int CAPACITY = 10;
    int arr[CAPACITY] = {10, 20, 30, 40, 50};
    int n = 5;  // Current number of elements
    
    cout << "Initial ";
    displayArray(arr, n);
    
    // Insert at end
    insertAtEnd(arr, n, CAPACITY, 60);
    displayArray(arr, n);
    
    // Insert at beginning
    insertAtBeginning(arr, n, CAPACITY, 5);
    displayArray(arr, n);
    
    // Insert at specific position
    insertAtPosition(arr, n, CAPACITY, 25, 3);
    displayArray(arr, n);
    
    // Try to insert at invalid position
    insertAtPosition(arr, n, CAPACITY, 100, 10);
    
    return 0;
}
</pre>
                            </div>
                        `
                    },
                    {
                        id: "3.4",
                        title: "Deletion from Arrays",
                        content: `
                            <p>Deletion involves removing an element from an array. After deletion, we need to shift elements to fill the gap.</p>
                            
                            <h4>Deletion Scenarios:</h4>
                            <ul>
                                <li><strong>From the end:</strong> Simply reduce the size counter</li>
                                <li><strong>From the beginning:</strong> Shift all elements left</li>
                                <li><strong>From specific position:</strong> Shift elements from that position onward</li>
                                <li><strong>By value:</strong> Find the element, then delete it</li>
                            </ul>
                            
                            <div class="complexity">
                                <h4>Time Complexity:</h4>
                                <ul>
                                    <li><strong>From the end:</strong> O(1)</li>
                                    <li><strong>From beginning/middle:</strong> O(n) - due to shifting</li>
                                </ul>
                            </div>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Array Deletion Operations</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

// Function to delete from the end
void deleteFromEnd(int arr[], int &n) {
    if (n > 0) {
        cout << "Element " << arr[n-1] << " deleted from the end." << endl;
        n--;
    } else {
        cout << "Array is empty! Cannot delete." << endl;
    }
}

// Function to delete from beginning
void deleteFromBeginning(int arr[], int &n) {
    if (n > 0) {
        cout << "Element " << arr[0] << " deleted from the beginning." << endl;
        
        // Shift all elements to the left
        for (int i = 0; i < n - 1; i++) {
            arr[i] = arr[i + 1];
        }
        n--;
    } else {
        cout << "Array is empty! Cannot delete." << endl;
    }
}

// Function to delete from specific position
void deleteFromPosition(int arr[], int &n, int position) {
    if (n == 0) {
        cout << "Array is empty! Cannot delete." << endl;
        return;
    }
    
    if (position < 0 || position >= n) {
        cout << "Invalid position!" << endl;
        return;
    }
    
    cout << "Element " << arr[position] << " deleted from position " << position << "." << endl;
    
    // Shift elements from position to end
    for (int i = position; i < n - 1; i++) {
        arr[i] = arr[i + 1];
    }
    n--;
}

// Function to delete by value
void deleteByValue(int arr[], int &n, int value) {
    if (n == 0) {
        cout << "Array is empty! Cannot delete." << endl;
        return;
    }
    
    // Find the element
    int position = -1;
    for (int i = 0; i < n; i++) {
        if (arr[i] == value) {
            position = i;
            break;
        }
    }
    
    if (position == -1) {
        cout << "Element " << value << " not found in array." << endl;
        return;
    }
    
    // Delete from found position
    deleteFromPosition(arr, n, position);
}

void displayArray(int arr[], int n) {
    cout << "Array (" << n << " elements): ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    const int CAPACITY = 10;
    int arr[CAPACITY] = {10, 20, 30, 40, 50, 60, 70};
    int n = 7;  // Current number of elements
    
    cout << "Initial ";
    displayArray(arr, n);
    
    // Delete from end
    deleteFromEnd(arr, n);
    displayArray(arr, n);
    
    // Delete from beginning
    deleteFromBeginning(arr, n);
    displayArray(arr, n);
    
    // Delete from specific position
    deleteFromPosition(arr, n, 2);
    displayArray(arr, n);
    
    // Delete by value
    deleteByValue(arr, n, 40);
    displayArray(arr, n);
    
    // Try to delete non-existent value
    deleteByValue(arr, n, 100);
    
    return 0;
}
</pre>
                            </div>
                        `
                    },
                    {
                        id: "3.5",
                        title: "Sorting Arrays",
                        content: `
                            <p>Sorting arranges elements in a specific order (ascending or descending).</p>
                            
                            <h4>Common Sorting Algorithms:</h4>
                            <table class="comparison-table">
                                <thead>
                                    <tr>
                                        <th>Algorithm</th>
                                        <th>Best Case</th>
                                        <th>Average Case</th>
                                        <th>Worst Case</th>
                                        <th>Space</th>
                                        <th>Stable</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Bubble Sort</td>
                                        <td>O(n)</td>
                                        <td>O(n²)</td>
                                        <td>O(n²)</td>
                                        <td>O(1)</td>
                                        <td>Yes</td>
                                    </tr>
                                    <tr>
                                        <td>Selection Sort</td>
                                        <td>O(n²)</td>
                                        <td>O(n²)</td>
                                        <td>O(n²)</td>
                                        <td>O(1)</td>
                                        <td>No</td>
                                    </tr>
                                    <tr>
                                        <td>Insertion Sort</td>
                                        <td>O(n)</td>
                                        <td>O(n²)</td>
                                        <td>O(n²)</td>
                                        <td>O(1)</td>
                                        <td>Yes</td>
                                    </tr>
                                    <tr>
                                        <td>Merge Sort</td>
                                        <td>O(n log n)</td>
                                        <td>O(n log n)</td>
                                        <td>O(n log n)</td>
                                        <td>O(n)</td>
                                        <td>Yes</td>
                                    </tr>
                                    <tr>
                                        <td>Quick Sort</td>
                                        <td>O(n log n)</td>
                                        <td>O(n log n)</td>
                                        <td>O(n²)</td>
                                        <td>O(log n)</td>
                                        <td>No</td>
                                    </tr>
                                </tbody>
                            </table>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Bubble Sort Implementation</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        // Flag to optimize - if no swapping happened, array is sorted
        bool swapped = false;
        
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap elements
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        
        // If no swapping happened, array is already sorted
        if (!swapped) {
            break;
        }
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "Original array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    bubbleSort(arr, n);
    
    cout << "Sorted array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    return 0;
}
</pre>
                            </div>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Quick Sort Implementation</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

// Partition function for Quick Sort
int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // Choose last element as pivot
    int i = low - 1;        // Index of smaller element
    
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            // Swap arr[i] and arr[j]
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    
    // Swap arr[i+1] and arr[high] (pivot)
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    
    return i + 1;  // Return partition index
}

// Quick Sort function
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // pi is partitioning index
        int pi = partition(arr, low, high);
        
        // Recursively sort elements before and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "Original array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    quickSort(arr, 0, n - 1);
    
    cout << "Sorted array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    return 0;
}
</pre>
                            </div>
                        `
                    },
                    {
                        id: "3.6",
                        title: "Merging Arrays",
                        content: `
                            <p>Merging combines two sorted arrays into a single sorted array.</p>
                            
                            <h4>Merging Algorithm Steps:</h4>
                            <ol>
                                <li>Create a new array with size = size1 + size2</li>
                                <li>Compare elements of both arrays one by one</li>
                                <li>Copy the smaller element to the new array</li>
                                <li>Continue until all elements from both arrays are copied</li>
                            </ol>
                            
                            <div class="complexity">
                                <h4>Time Complexity:</h4>
                                <ul>
                                    <li><strong>Time:</strong> O(n + m) where n and m are sizes of arrays</li>
                                    <li><strong>Space:</strong> O(n + m) for the new array</li>
                                </ul>
                            </div>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Merging Two Sorted Arrays</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

// Function to merge two sorted arrays
int* mergeArrays(int arr1[], int n1, int arr2[], int n2) {
    int* merged = new int[n1 + n2];
    int i = 0, j = 0, k = 0;
    
    // Merge while both arrays have elements
    while (i < n1 && j < n2) {
        if (arr1[i] <= arr2[j]) {
            merged[k] = arr1[i];
            i++;
        } else {
            merged[k] = arr2[j];
            j++;
        }
        k++;
    }
    
    // Copy remaining elements of arr1, if any
    while (i < n1) {
        merged[k] = arr1[i];
        i++;
        k++;
    }
    
    // Copy remaining elements of arr2, if any
    while (j < n2) {
        merged[k] = arr2[j];
        j++;
        k++;
    }
    
    return merged;
}

int main() {
    int arr1[] = {1, 3, 5, 7, 9};
    int arr2[] = {2, 4, 6, 8, 10, 12, 14};
    
    int n1 = sizeof(arr1) / sizeof(arr1[0]);
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    
    cout << "Array 1: ";
    for (int i = 0; i < n1; i++) {
        cout << arr1[i] << " ";
    }
    cout << endl;
    
    cout << "Array 2: ";
    for (int i = 0; i < n2; i++) {
        cout << arr2[i] << " ";
    }
    cout << endl;
    
    int* merged = mergeArrays(arr1, n1, arr2, n2);
    
    cout << "Merged array: ";
    for (int i = 0; i < n1 + n2; i++) {
        cout << merged[i] << " ";
    }
    cout << endl;
    
    delete[] merged;  // Free allocated memory
    
    return 0;
}
</pre>
                            </div>
                            
                            <h4>In-Place Merging (for arrays with extra space):</h4>
                            <div class="code-container">
                                <div class="code-header">
                                    <span>In-Place Merge Implementation</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

// Function to merge two sorted parts of a single array
void mergeInPlace(int arr[], int left, int mid, int right) {
    int leftSize = mid - left + 1;
    int rightSize = right - mid;
    
    // Create temporary arrays
    int leftArr[leftSize], rightArr[rightSize];
    
    // Copy data to temp arrays
    for (int i = 0; i < leftSize; i++) {
        leftArr[i] = arr[left + i];
    }
    for (int j = 0; j < rightSize; j++) {
        rightArr[j] = arr[mid + 1 + j];
    }
    
    // Merge temp arrays back into arr[left..right]
    int i = 0, j = 0, k = left;
    
    while (i < leftSize && j < rightSize) {
        if (leftArr[i] <= rightArr[j]) {
            arr[k] = leftArr[i];
            i++;
        } else {
            arr[k] = rightArr[j];
            j++;
        }
        k++;
    }
    
    // Copy remaining elements of leftArr[]
    while (i < leftSize) {
        arr[k] = leftArr[i];
        i++;
        k++;
    }
    
    // Copy remaining elements of rightArr[]
    while (j < rightSize) {
        arr[k] = rightArr[j];
        j++;
        k++;
    }
}

int main() {
    // Example: Array with two sorted halves
    int arr[] = {1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    // First half: [0..4] is sorted, Second half: [5..9] is sorted
    int mid = 4;  // Last index of first sorted half
    
    cout << "Original array with two sorted halves:" << endl;
    cout << "First half: ";
    for (int i = 0; i <= mid; i++) {
        cout << arr[i] << " ";
    }
    cout << endl << "Second half: ";
    for (int i = mid + 1; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    // Merge the two halves
    mergeInPlace(arr, 0, mid, n - 1);
    
    cout << "Merged sorted array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    return 0;
}
</pre>
                            </div>
                        `
                    }
                ]
            },
            {
                id: 4,
                title: "Module 4: Linked Lists",
                topics: [
                    {
                        id: "4.1",
                        title: "Linked List Overview",
                        content: `
                            <p>A linked list is a linear data structure where elements (nodes) are stored at non-contiguous memory locations. Each node contains data and a pointer to the next node.</p>
                            
                            <h4>Advantages over Arrays:</h4>
                            <ul>
                                <li>Dynamic size - can grow/shrink during execution</li>
                                <li>Efficient insertion/deletion - no need to shift elements</li>
                                <li>Memory efficiency - uses memory only as needed</li>
                            </ul>
                            
                            <h4>Disadvantages:</h4>
                            <ul>
                                <li>Random access not possible - must traverse from head</li>
                                <li>Extra memory for pointers</li>
                                <li>Not cache-friendly due to non-contiguous memory</li>
                            </ul>
                            
                            <div class="visualization">
                                <h4>Linked List Structure</h4>
                                <div style="display: flex; align-items: center; justify-content: center;">
                                    <div style="display: flex; align-items: center;">
                                        <div style="border: 2px solid #3498db; border-radius: 5px; padding: 10px; margin: 5px;">
                                            <div>Data: 10</div>
                                            <div>Next: →</div>
                                        </div>
                                        <div class="visual-pointer">→</div>
                                        <div style="border: 2px solid #3498db; border-radius: 5px; padding: 10px; margin: 5px;">
                                            <div>Data: 20</div>
                                            <div>Next: →</div>
                                        </div>
                                        <div class="visual-pointer">→</div>
                                        <div style="border: 2px solid #3498db; border-radius: 5px; padding: 10px; margin: 5px;">
                                            <div>Data: 30</div>
                                            <div>Next: NULL</div>
                                        </div>
                                    </div>
                                </div>
                                <p>Each node contains data and a pointer to the next node</p>
                            </div>
                        `
                    },
                    {
                        id: "4.2",
                        title: "Why Linked Lists",
                        content: `
                            <p>Linked lists solve several problems inherent in array-based data structures:</p>
                            
                            <h4>Key Reasons to Use Linked Lists:</h4>
                            
                            <table class="comparison-table">
                                <thead>
                                    <tr>
                                        <th>Scenario</th>
                                        <th>Array Problem</th>
                                        <th>Linked List Solution</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Dynamic Size</td>
                                        <td>Fixed size, expensive resizing</td>
                                        <td>Grows/shrinks dynamically</td>
                                    </tr>
                                    <tr>
                                        <td>Frequent Insertions/Deletions</td>
                                        <td>O(n) time for shifting elements</td>
                                        <td>O(1) time for known position</td>
                                    </tr>
                                    <tr>
                                        <td>Memory Usage</td>
                                        <td>May allocate more than needed</td>
                                        <td>Uses memory proportional to data</td>
                                    </tr>
                                    <tr>
                                        <td>Memory Fragmentation</td>
                                        <td>Needs contiguous memory block</td>
                                        <td>Uses scattered memory locations</td>
                                    </tr>
                                </tbody>
                            </table>
                            
                            <h4>Use Cases for Linked Lists:</h4>
                            <ul>
                                <li><strong>Implementation of Stacks and Queues:</strong> Efficient push/pop operations</li>
                                <li><strong>Dynamic Memory Allocation:</strong> Like in operating systems</li>
                                <li><strong>Undo Functionality:</strong> In text editors or software</li>
                                <li><strong>Hash Tables:</strong> For chaining collision resolution</li>
                                <li><strong>Graphs:</strong> Adjacency list representation</li>
                                <li><strong>Polynomial Arithmetic:</strong> Storing polynomial terms</li>
                            </ul>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>When to Choose Linked List over Array</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

// Scenario demonstrating linked list advantage
void demonstrateAdvantage() {
    cout << "Scenario: Frequent insertions at beginning" << endl;
    cout << "==========================================" << endl;
    
    // With array: O(n) for each insertion at beginning
    cout << "Array approach:" << endl;
    cout << "- To insert at beginning: shift n elements" << endl;
    cout << "- Time complexity: O(n) per insertion" << endl;
    cout << "- For 1000 insertions: ~500,000 operations" << endl;
    cout << endl;
    
    // With linked list: O(1) for each insertion at beginning
    cout << "Linked list approach:" << endl;
    cout << "- To insert at beginning: update 2 pointers" << endl;
    cout << "- Time complexity: O(1) per insertion" << endl;
    cout << "- For 1000 insertions: 1000 operations" << endl;
}

int main() {
    demonstrateAdvantage();
    return 0;
}
</pre>
                            </div>
                        `
                    },
                    {
                        id: "4.3",
                        title: "Representation of Linked Lists in Memory",
                        content: `
                            <p>Linked lists use dynamic memory allocation. Each node is allocated separately, and nodes are connected via pointers.</p>
                            
                            <h4>Memory Layout:</h4>
                            <div class="visualization">
                                <h4>Linked List Memory Representation</h4>
                                <div style="text-align: left; background-color: white; padding: 15px; border-radius: 5px; display: inline-block;">
                                    <div><strong>Head Pointer:</strong> 0x1000 (points to first node)</div>
                                    <br>
                                    <div><strong>Node 1:</strong></div>
                                    <div style="margin-left: 20px;">Address: 0x1000</div>
                                    <div style="margin-left: 20px;">Data: 10</div>
                                    <div style="margin-left: 20px;">Next: 0x2000</div>
                                    <br>
                                    <div><strong>Node 2:</strong></div>
                                    <div style="margin-left: 20px;">Address: 0x2000</div>
                                    <div style="margin-left: 20px;">Data: 20</div>
                                    <div style="margin-left: 20px;">Next: 0x3000</div>
                                    <br>
                                    <div><strong>Node 3:</strong></div>
                                    <div style="margin-left: 20px;">Address: 0x3000</div>
                                    <div style="margin-left: 20px;">Data: 30</div>
                                    <div style="margin-left: 20px;">Next: NULL (0x0)</div>
                                </div>
                            </div>
                            
                            <h4>Node Structure in C++:</h4>
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Basic Node Structure</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

// Definition of a node
struct Node {
    int data;        // Data part
    Node* next;      // Pointer to next node
    
    // Constructor for easy node creation
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

int main() {
    // Creating nodes
    Node* head = new Node(10);
    Node* second = new Node(20);
    Node* third = new Node(30);
    
    // Linking nodes
    head->next = second;
    second->next = third;
    // third->next is already nullptr from constructor
    
    // Traverse and display
    cout << "Linked List: ";
    Node* current = head;
    while (current != nullptr) {
        cout << current->data << " -> ";
        current = current->next;
    }
    cout << "NULL" << endl;
    
    // Display memory addresses
    cout << "\nMemory addresses:" << endl;
    cout << "Head pointer: " << &head << endl;
    cout << "Node 1 address: " << head << ", Data: " << head->data 
         << ", Next: " << head->next << endl;
    cout << "Node 2 address: " << second << ", Data: " << second->data 
         << ", Next: " << second->next << endl;
    cout << "Node 3 address: " << third << ", Data: " << third->data 
         << ", Next: " << third->next << endl;
    
    // Free memory
    delete head;
    delete second;
    delete third;
    
    return 0;
}
</pre>
                            </div>
                        `
                    },
                    {
                        id: "4.4",
                        title: "Memory Allocation",
                        content: `
                            <p>Linked lists use dynamic memory allocation. In C++, we use <code>new</code> to allocate nodes and <code>delete</code> to free them.</p>
                            
                            <h4>Memory Allocation Process:</h4>
                            <ol>
                                <li><strong>Allocation:</strong> <code>new Node(value)</code> requests memory from heap</li>
                                <li><strong>Initialization:</strong> Constructor initializes the node</li>
                                <li><strong>Linking:</strong> Pointers connect nodes</li>
                                <li><strong>Deallocation:</strong> <code>delete node</code> returns memory to heap</li>
                            </ol>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Memory Management in Linked Lists</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
    
    Node(int value) : data(value), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;
    
public:
    LinkedList() : head(nullptr) {}
    
    // Insert at beginning
    void insertAtBeginning(int value) {
        Node* newNode = new Node(value);  // Step 1: Allocation
        newNode->next = head;             // Step 2: Linking
        head = newNode;                   // Step 3: Update head
        cout << "Allocated node for value " << value << endl;
    }
    
    // Display list
    void display() {
        Node* current = head;
        cout << "List: ";
        while (current != nullptr) {
            cout << current->data << " -> ";
            current = current->next;
        }
        cout << "NULL" << endl;
    }
    
    // Delete from beginning
    void deleteFromBeginning() {
        if (head == nullptr) {
            cout << "List is empty!" << endl;
            return;
        }
        
        Node* temp = head;
        head = head->next;
        cout << "Deallocating node with value " << temp->data << endl;
        delete temp;  // Step 4: Deallocation
    }
    
    // Destructor to free all memory
    ~LinkedList() {
        cout << "\nDestructor called. Cleaning up memory..." << endl;
        while (head != nullptr) {
            deleteFromBeginning();
        }
    }
};

int main() {
    LinkedList list;
    
    cout << "=== Memory Allocation Demo ===" << endl;
    
    // Allocate nodes
    list.insertAtBeginning(30);
    list.insertAtBeginning(20);
    list.insertAtBeginning(10);
    
    list.display();
    
    // Deallocate one node
    cout << "\nDeleting from beginning:" << endl;
    list.deleteFromBeginning();
    list.display();
    
    // Destructor will automatically free remaining memory
    cout << "\nEnd of main(). Destructor will be called automatically." << endl;
    
    return 0;
}
</pre>
                            </div>
                            
                            <h4>Memory Leak Prevention:</h4>
                            <p>Always ensure proper deallocation to prevent memory leaks:</p>
                            <ul>
                                <li>Use destructors to clean up</li>
                                <li>Delete nodes in reverse order of allocation</li>
                                <li>Set pointers to nullptr after deletion</li>
                            </ul>
                        `
                    },
                    {
                        id: "4.5",
                        title: "Overflow and Underflow",
                        content: `
                            <p>Overflow and underflow are conditions that occur when trying to perform operations beyond the data structure's capacity.</p>
                            
                            <h4>Overflow:</h4>
                            <p>Occurs when trying to insert into a data structure that has no space left. In linked lists, overflow typically happens when memory allocation fails (heap exhaustion).</p>
                            
                            <h4>Underflow:</h4>
                            <p>Occurs when trying to delete from an empty data structure.</p>
                            
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Handling Overflow and Underflow</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
#include &lt;new&gt;  // For std::bad_alloc
using namespace std;

struct Node {
    int data;
    Node* next;
    
    Node(int value) : data(value), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;
    
public:
    LinkedList() : head(nullptr) {}
    
    // Insert with overflow check
    void insert(int value) {
        try {
            Node* newNode = new Node(value);  // May throw bad_alloc
            
            if (head == nullptr) {
                head = newNode;
            } else {
                Node* current = head;
                while (current->next != nullptr) {
                    current = current->next;
                }
                current->next = newNode;
            }
            
            cout << "Successfully inserted " << value << endl;
        } 
        catch (const bad_alloc& e) {
            cout << "OVERFLOW: Memory allocation failed for value " 
                 << value << "!" << endl;
            cout << "Error: " << e.what() << endl;
        }
    }
    
    // Delete with underflow check
    void deleteFromEnd() {
        if (head == nullptr) {
            cout << "UNDERFLOW: List is empty! Cannot delete." << endl;
            return;
        }
        
        if (head->next == nullptr) {
            // Only one node
            delete head;
            head = nullptr;
        } else {
            Node* current = head;
            Node* prev = nullptr;
            
            while (current->next != nullptr) {
                prev = current;
                current = current->next;
            }
            
            prev->next = nullptr;
            delete current;
        }
        
        cout << "Successfully deleted from end" << endl;
    }
    
    void display() {
        if (head == nullptr) {
            cout << "List is empty" << endl;
            return;
        }
        
        Node* current = head;
        cout << "List: ";
        while (current != nullptr) {
            cout << current->data << " -> ";
            current = current->next;
        }
        cout << "NULL" << endl;
    }
};

// Function to simulate memory exhaustion
void simulateOverflow() {
    cout << "\n=== Simulating Memory Overflow ===" << endl;
    LinkedList list;
    
    // Try to allocate an unrealistic amount of memory
    long long counter = 0;
    try {
        while (true) {
            list.insert(counter++);
            if (counter % 10000 == 0) {
                cout << "Allocated " << counter << " nodes so far..." << endl;
            }
        }
    } 
    catch (const bad_alloc&) {
        cout << "\nCaught bad_alloc after " << counter << " allocations" << endl;
    }
}

int main() {
    cout << "=== Overflow and Underflow Demo ===" << endl;
    
    LinkedList list;
    
    // Test underflow
    cout << "\n1. Testing underflow (deleting from empty list):" << endl;
    list.deleteFromEnd();
    
    // Normal operations
    cout << "\n2. Normal insertions:" << endl;
    list.insert(10);
    list.insert(20);
    list.insert(30);
    list.display();
    
    // Normal deletion
    cout << "\n3. Normal deletion:" << endl;
    list.deleteFromEnd();
    list.display();
    
    // Delete until underflow
    cout << "\n4. Deleting until underflow:" << endl;
    list.deleteFromEnd();
    list.deleteFromEnd();
    list.deleteFromEnd();  // This should cause underflow
    
    // Uncomment to test memory overflow (may crash system)
    // simulateOverflow();
    
    return 0;
}
</pre>
                            </div>
                            
                            <h4>Best Practices:</h4>
                            <ul>
                                <li>Always check for empty list before deletion</li>
                                <li>Handle <code>bad_alloc</code> exceptions for <code>new</code> operations</li>
                                <li>Implement proper error messages for users</li>
                                <li>Consider alternative data structures if overflow is frequent</li>
                            </ul>
                        `
                    },
                    {
                        id: "4.6",
                        title: "Basic Operations of Linked Lists",
                        content: `
                            <p>Basic operations include creation, insertion, deletion, traversal, and searching.</p>
                            
                            <h4>Complete Linked List Implementation:</h4>
                            <div class="code-container">
                                <div class="code-header">
                                    <span>Complete Linked List with All Operations</span>
                                    <button class="code-copy" onclick="copyCode(this)">Copy</button>
                                </div>
<pre>
#include &lt;iostream&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
    
    Node(int value) : data(value), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;
    
    Node* createNode(int value) {
        return new Node(value);
    }
    
public:
    LinkedList() : head(nullptr) {}
    
    // 1. Insert at beginning
    void insertAtBeginning(int value) {
        Node* newNode = createNode(value);
        newNode->next = head;
        head = newNode;
    }
    
    // 2. Insert at end
    void insertAtEnd(int value) {
        Node* newNode = createNode(value);
        
        if (head == nullptr) {
            head = newNode;
            return;
        }
        
        Node* current = head;
        while (current->next != nullptr) {
            current = current->next;
        }
        current->next = newNode;
    }
    
    // 3. Insert at specific position
    void insertAtPosition(int value, int position) {
        if (position < 0) {
            cout << "Invalid position!" << endl;
            return;
        }
        
        if (position == 0) {
            insertAtBeginning(value);
            return;
        }
        
        Node* newNode = createNode(value);
        Node* current = head;
        int currentPos = 0;
        
        // Move to node before the position
        while (current != nullptr && currentPos < position - 1) {
            current = current->next;
            currentPos++;
        }
        
        if (current == nullptr) {
            cout << "Position out of bounds!" << endl;
            delete newNode;
            return;
        }
        
        newNode->next = current->next;
        current->next = newNode;
    }
    
    // 4. Delete from beginning
    void deleteFromBeginning() {
        if (head == nullptr) {
            cout << "List is empty!" << endl;
            return;
        }
        
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    
    // 5. Delete from end
    void deleteFromEnd() {
        if (head == nullptr) {
            cout << "List is empty!" << endl;
            return;
        }
        
        if (head->next == nullptr) {
            delete head;
            head = nullptr;
            return;
        }
        
        Node* current = head;
        while (current->next->next != nullptr) {
            current = current->next;
        }
        
        delete current->next;
        current->next = nullptr;
    }
    
    // 6. Delete by value
    void deleteByValue(int value) {
        if (head == nullptr) {
            cout << "List is empty!" << endl;
            return;
        }
        
        // If head needs to be deleted
        if (head->data == value) {
            deleteFromBeginning();
            return;
        }
        
        Node* current = head;
        while (current->next != nullptr && current->next->data != value) {
            current = current->next;
        }
        
        if (current->next == nullptr) {
            cout << "Value " << value << " not found in list!" << endl;
            return;
        }
        
        Node* temp = current->next;
        current->next = current->next->next;
        delete temp;
    }
    
    // 7. Search for a value
    bool search(int value) {
        Node* current = head;
        int position = 0;
        
        while (current != nullptr) {
            if (current->data == value) {
                cout << "Value " << value << " found at position " << position << endl;
                return true;
            }
            current = current->next;
            position++;
        }
        
        cout << "Value " << value << " not found in list!" << endl;
        return false;
    }
    
    // 8. Get length of list
    int getLength() {
        int length = 0;
        Node* current = head;
        
        while (current != nullptr) {
            length++;
            current = current->next;
        }
        
        return length;
    }
    
    // 9. Reverse the list
    void reverse() {
        Node* prev = nullptr;
        Node* current = head;
        Node* next = nullptr;
        
        while (current != nullptr) {
            next = current->next;  // Store next node
            current->next = prev;  // Reverse current node's pointer
            prev = current;        // Move pointers one position ahead
            current = next;
        }
        
        head = prev;  // Update head to new first node
    }
    
    // 10. Display the list
    void display() {
        if (head == nullptr) {
            cout << "List is empty!" << endl;
            return;
        }
        
        Node* current = head;
        cout << "Linked List: ";
        while (current != nullptr) {
            cout << current->data;
            if (current->next != nullptr) {
                cout << " -> ";
            }
            current = current->next;
        }
        cout << " -> NULL" << endl;
    }
    
    // Destructor
    ~LinkedList() {
        while (head != nullptr) {
            deleteFromBeginning();
        }
    }
};

int main() {
    LinkedList list;
    
    cout << "=== Linked List Operations Demo ===" << endl;
    
    // Insert operations
    cout << "\n1. Inserting elements:" << endl;
    list.insertAtEnd(10);
    list.insertAtEnd(20);
    list.insertAtBeginning(5);
    list.insertAtPosition(15, 2);
    list.display();
    
    // Search operations
    cout << "\n2. Searching elements:" << endl;
    list.search(15);
    list.search(100);  // Not in list
    
    // Get length
    cout << "\n3. Length of list: " << list.getLength() << endl;
    
    // Delete operations
    cout << "\n4. Deleting elements:" << endl;
    list.deleteFromBeginning();
    cout << "After deleting from beginning:" << endl;
    list.display();
    
    list.deleteFromEnd();
    cout << "After deleting from end:" << endl;
    list.display();
    
    list.deleteByValue(15);
    cout << "After deleting value 15:" << endl;
    list.display();
    
    // Reverse list
    cout << "\n5. Reversing list:" << endl;
    list.insertAtEnd(25);
    list.insertAtEnd(30);
    cout << "Before reverse:" << endl;
    list.display();
    
    list.reverse();
    cout << "After reverse:" << endl;
    list.display();
    
    return 0;
}
</pre>
                            </div>
                            
                            <h4>Time Complexity Summary:</h4>
                            <table class="comparison-table">
                                <thead>
                                    <tr>
                                        <th>Operation</th>
                                        <th>Time Complexity</th>
                                        <th>Notes</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Insert at beginning</td>
                                        <td>O(1)</td>
                                        <td>Constant time</td>
                                    </tr>
                                    <tr>
                                        <td>Insert at end</td>
                                        <td>O(n)</td>
                                        <td>Need to traverse to end</td>
                                    </tr>
                                    <tr>
                                        <td>Insert at position</td>
                                        <td>O(n)</td>
                                        <td>Worst case</td>
                                    </tr>
                                    <tr>
                                        <td>Delete from beginning</td>
                                        <td>O(1)</td>
                                        <td>Constant time</td>
                                    </tr>
                                    <tr>
                                        <td>Delete from end</td>
                                        <td>O(n)</td>
                                        <td>Need to traverse to end</td>
                                    </tr>
                                    <tr>
                                        <td>Search</td>
                                        <td>O(n)</td>
                                        <td>Linear search</td>
                                    </tr>
                                    <tr>
                                        <td>Access by index</td>
                                        <td>O(n)</td>
                                        <td>Must traverse</td>
                                    </tr>
                                    <tr>
                                        <td>Reverse</td>
                                        <td>O(n)</td>
                                        <td>Traverse once</td>
                                    </tr>
                                </tbody>
                            </table>
                        `
                    }
                ]
            }
            // Note: For brevity, I've shown Modules 1-4 in detail.
            // Modules 5-12 would follow the same pattern with appropriate content.
        ];
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Generate module navigation
            const moduleNav = document.getElementById('moduleNav');
            const moduleMenu = document.getElementById('moduleMenu');
            const mainContent = document.getElementById('mainContent');
            
            // Create module navigation
            modules.forEach((module, index) => {
                // Top navigation
                const navItem = document.createElement('li');
                navItem.textContent = `Module ${module.id}`;
                navItem.dataset.moduleId = module.id;
                navItem.addEventListener('click', () => loadModule(module.id));
                if (index === 0) navItem.classList.add('active');
                moduleNav.appendChild(navItem);
                
                // Sidebar menu
                const menuHeader = document.createElement('li');
                menuHeader.innerHTML = `<h4>${module.title}</h4>`;
                moduleMenu.appendChild(menuHeader);
                
                // Topics in sidebar
                module.topics.forEach(topic => {
                    const menuItem = document.createElement('li');
                    const link = document.createElement('a');
                    link.href = `#${topic.id}`;
                    link.textContent = topic.title;
                    link.dataset.topicId = topic.id;
                    link.dataset.moduleId = module.id;
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        loadTopic(module.id, topic.id);
                    });
                    menuItem.appendChild(link);
                    moduleMenu.appendChild(menuItem);
                });
            });
            
            // Load first module by default
            loadModule(1);
            
            // Copy code functionality
            window.copyCode = function(button) {
                const codeElement = button.parentElement.nextElementSibling;
                const textArea = document.createElement('textarea');
                textArea.value = codeElement.textContent;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                // Visual feedback
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.backgroundColor = '#27ae60';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = '';
                }, 2000);
            };
        });
        
        // Function to load a module
        function loadModule(moduleId) {
            // Update navigation
            document.querySelectorAll('.module-list li').forEach(item => {
                item.classList.remove('active');
                if (parseInt(item.dataset.moduleId) === moduleId) {
                    item.classList.add('active');
                }
            });
            
            // Update sidebar menu
            document.querySelectorAll('.module-menu a').forEach(link => {
                link.classList.remove('active');
                if (parseInt(link.dataset.moduleId) === moduleId && link.dataset.topicId === '1.1') {
                    link.classList.add('active');
                }
            });
            
            // Find the module
            const module = modules.find(m => m.id === moduleId);
            if (!module) return;
            
            // Clear main content
            mainContent.innerHTML = '';
            
            // Create module header
            const moduleHeader = document.createElement('div');
            moduleHeader.className = 'module-header';
            moduleHeader.innerHTML = `
                <h2>${module.title}</h2>
                <p>Select a topic from the sidebar or use the navigation above</p>
            `;
            mainContent.appendChild(moduleHeader);
            
            // Create container for all topics
            const topicsContainer = document.createElement('div');
            topicsContainer.id = 'topicsContainer';
            
            // Add all topics
            module.topics.forEach(topic => {
                const topicElement = document.createElement('div');
                topicElement.className = 'module';
                topicElement.id = `topic-${topic.id}`;
                topicElement.innerHTML = `
                    <h3>${topic.title}</h3>
                    ${topic.content}
                `;
                topicsContainer.appendChild(topicElement);
            });
            
            mainContent.appendChild(topicsContainer);
            
            // Show first topic
            document.getElementById(`topic-${module.topics[0].id}`).classList.add('active');
            
            // Scroll to top
            mainContent.scrollTop = 0;
        }
        
        // Function to load a specific topic
        function loadTopic(moduleId, topicId) {
            // Load module first if not already loaded
            const currentModule = document.querySelector('.module-list li.active');
            if (!currentModule || parseInt(currentModule.dataset.moduleId) !== moduleId) {
                loadModule(moduleId);
            }
            
            // Update sidebar menu
            document.querySelectorAll('.module-menu a').forEach(link => {
                link.classList.remove('active');
                if (link.dataset.topicId === topicId) {
                    link.classList.add('active');
                }
            });
            
            // Hide all topics
            document.querySelectorAll('.module').forEach(topic => {
                topic.classList.remove('active');
            });
            
            // Show selected topic
            const selectedTopic = document.getElementById(`topic-${topicId}`);
            if (selectedTopic) {
                selectedTopic.classList.add('active');
                
                // Scroll to topic
                selectedTopic.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
    </script>
</body>
</html>